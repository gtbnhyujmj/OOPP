 白話翻譯：
「建立物件的時候會以該類別為主，如果該類別沒有才會往上找。」

意思是：

如果你用「子類別」建立物件，那這個物件會先找自己的方法或屬性，如果找不到，才會去找「父類別」裡面有沒有。

這就是 繼承的搜尋順序（method resolution order，MRO）

搜尋順序是怎樣？
Python 會這樣找：

子類別（自己有沒有？）

父類別（爸有沒有？）

再上層祖先（阿公有沒有？）← 如果你有多層繼承


覆蓋（Override）
python
複製
編輯
class Person:
    def say_hi(self):
        print("嗨，我是人類")

class Student(Person):
    def say_hi(self):
        print("嗨，我是學生")

s = Student()
s.say_hi()   # 🔍 找到的是 Student 的 say_hi，不會去找 Person 的了
👉 輸出：
複製
編輯
嗨，我是學生
因為子類別已經「自己有了」，就不會再往上找。



✅ 小結（記下這句話就懂）
Python 建立物件時，會先用自己類別裡的屬性/方法，
如果找不到，才會去父類別裡面找。

Python 的「繼承搜尋順序」
真的就像你說的：

🔸 特別法優先原則（Lex specialis derogat legi generali）
子類別（自己） = 特別法

父類別 = 一般法

🔍 Python 會 先看「子類別」有沒有定義方法或屬性，有的話就用它（特別法優先）
沒有的話，才會「準用」父類別（一般法）

🔸 準用的概念是什麼？
在法律上：

某個條文沒講清楚，就去別的條文「借用」規定來補充。

在 Python：

子類別沒定義某功能，就「準用」父類別的定義。

✅ 用你語言系統的眼光來整理：
Python 類別	法律概念	說明
子類別（class Student）	特別法	優先使用自己的規定（定義）
父類別（class Person）	一般法	如果子類別沒有，才準用這裡的內容
覆寫（Override）	特別法排除一般法	子類別自己定義了，就不適用父類別的定義
沒寫就往上找	準用	子類別沒寫，Python 會往上爬找父類別方法
