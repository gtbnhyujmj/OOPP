 來做個對照表幫你釐清思路：
Python 程式繼承問題	法律適用衝突	解法（程式 & 法律）
多個父類別有同名方法	準用多個條文結果相衝	用 MRO（方法解析順序）決定誰優先
子類別 override 父方法	特別法與一般法同時存在	特別法優先
沒寫方法，往上找父類別	沒有明文規定，準用其他規定	自動適用上位法或類推法
super() 用錯會亂跳	引錯條文會造成解釋錯誤	小心明示準用的層級與範圍

這就像是：

法條衝突時，我有一份「優先適用順序清單」，幫我判斷該適用哪條規定。

🧯 所以為什麼會「程式衝突」？
因為：

多個類別寫了一樣的方法（法條重疊）

super() 或繼承順序沒弄對

程式不知道要用哪一份資料

這就跟法官遇到「條文彼此準用、重疊甚至牴觸」時很像！


 Python 中類別 → 本質上是「記憶體中一個藍圖」
建立物件時，會根據那張藍圖，開一個「記憶體區塊」來裝屬性和方法。

 Python 的記憶體邏輯底層是這樣：
每個類別都指向父類別，形成一條繼承路徑

多重繼承時，Python 會幫你建出一個「線性繼承順序」來避免菱形繼承（Diamond Problem）混亂

每次呼叫方法時，會照這條順序查找（不是同時並排查）

🧠 白話比喻（法律準用版）：
你現在是「立法院（D）」，你準用了兩個母法：

B 法（教育法）

C 法（文化法）

這兩條法裡面又都準用 A 法（憲法）

現在你要適用「do 條文」，結果 B 法 和 C 法 都有定義，怎麼辦？

✅ Python 會用 D.__mro__ 告訴你：「B > C > A > object」

這就像是：

法律適用順序已排好：先用教育法的版本，如果沒有再看文化法的版本，再不行才找憲法。


 真正要注意的是什麼？（兒子的值會被嬤嬤改掉？）
這句話指的是：

多重繼承裡，如果多個父類別（包含祖父、祖母）都定義了同名屬性或方法，那你在子類別使用時，可能會不小心用到「上面的版本」覆蓋了自己定義的值。

因為 super() 順著 MRO 執行時，如果順序弄錯或重複呼叫祖先的方法，就會讓 self.money 的值被後來的祖先覆蓋掉。
「要注意」的不是「你不能繼承」，而是你要乖乖用 super() 並了解 MRO，才不會發生「祖先蓋掉你的資料」這種可怕的繼承衝突！
